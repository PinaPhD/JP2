//@Author: Agrippina Mwangi
//Task Description: Investigating the dependability of SDN-enabled IoT-Edge networks for next-generation offshore wind farms

ctmc

//Normalized by the second - For Params I
const double y2s = (365.25*24*60*60);    //Normalizing factor -From year to seconds
const double h2s = (60*60);              //Normalizing factor -From year to seconds

//Failure Rates
const double lambdaC= 1/50*y2s;           //controller failure rate
const double lambdaSW = 1/25*y2s;          //switch failure rate
const double deltaC = 1/3600*h2s;          //controller failure detection rate

//Repair Rates
const double muC = 1/2*h2s;                //controller repair rate
const double muS = 1/2*h2s;                //switch repair rate

//Time-bound events
const double lambdaM = 1/3600;         //switch migration rate -detC to migS jump rate
const double lambdaDS = 1/360000;        //switch failure detection rate

//constraints
const double MIN_SENSORS = 2;  		   //minimum number of active sensors (system to continue running)
const double MIN_ACTUATORS = 2;  	   //minimum number of active actuators (system to continue running)
const double MIN_CONTROLLERS = 1;         //Maximum number of controllers
const double MIN_SWITCHES = 6;           //ring topology requirement


//mid-transition rates
const double dc = 1/11*y2s; 		// W1 to detC jump rate
const double ss = 1/3*y2s;                // migS to W2 jump rate
const double alphaS = 1/4*y2s;            // fdetS to W1 jump rate
const double deltaS = 1/2*y2s;            // detS to fdetS jump rate
const double alphaC = 1/y2s;            //fdetC to W1 jump rate

module switch
	//OpenFlow Switch at the Data Plane 
	//Source Switch (SW1) receives data samples from LDAQ and sends them to the destination Switch (SW9) 
	//to the ECP and vPAC nodes.
	sw : [0..9] init 9;                                    //9 switch network - ring topology
	[switch_fails] sw>0 -> sw*lambdaSW: (sw'=sw-1);       //when a single switch fails (NFV instance)
endmodule


module controller
	//Controller at the Control Plane
	c : [0..5] init 5;                        //5 controllers in the network
	[controller_fails] c>1 -> c*lambdaC : (c'=c-1);          //When a single controller fails 
endmodule

module controlplane
	//Defining the working states and the transition jump rates for the SDN IoT-Edge Network
	// 3 - Working state, 2 - Detect Controller Failure (detC), 1 - fail to detect controller failure, 0 -Failed state
	cp : [0..3] init 3;    	   		//Start from the working state
	
	[detC] (cp>0 & c>MIN_CONTROLLERS) -> dc : (cp'=2);   //moves to the detC state
	[fdetC] (cp=2 & c>MIN_CONTROLLERS) -> deltaC : (cp'=1);     //moves to fdetC state
	//Sends another HBR to confirm if the controller is still active
	[trigger_logs] (cp=1 & c>MIN_CONTROLLERS) -> alphaC : (cp'=3);      
	[fail] (cp=1 & c>MIN_CONTROLLERS) | (cp=1 & c=MIN_CONTROLLERS) | (sw>MIN_SWITCHES)-> lambdaC : (cp' = 0); 
	//repairing the controller (Reboot or Migrate VM)
	[repair] (cp=0 & c>MIN_CONTROLLERS) -> muC : (cp'=3);         

endmodule

module net
	cd : [0..3] init 3; //3-W1, 2-W2, 1-W3, 0- F
	 // Transition from cd=3 (F) to cd=2 (W3) through detection of controller failure and then failing to detect controller failure
        [detC] (cd=3) & (cp>0 & c>MIN_CONTROLLERS) -> dc : (cd'=2); // Transition to detC state in sdniotedgenet and W3 in cd_module
        [fdetC] (cd=2) & (cp=2 & c>MIN_CONTROLLERS) -> deltaC : (cd'=3); // Transition to fdetC state in sdniotedgenet and back to F in cd_module

    	// Transition from cd=3 (F) to cd=2 (W3) through detection of controller failure and then to a failed state
        [detC] (cd=3) & (cp>0 & c>MIN_CONTROLLERS) -> dc : (cd'=2); // Same as above
        [fail] (cd=2) & ((cp=1 & c>MIN_CONTROLLERS) | (cp=1 & c=MIN_CONTROLLERS) | (sw>MIN_SWITCHES)) -> lambdaC : (cd'=1); // Transition to fail state in sdniotedgenet and W2 in cd_module


endmodule

//Failed State (F)
formula failed = (cp=0) | (cd=0) ;

//Degraded State(D)
formula degraded = (cd=1)|(cd=2) ;

//Working State (W)
formula working = (cp=3) & (cd=3);


//Assigning rewards to assess the performance
rewards "reliability"
    working: 100; // High reward for being in a fully working state
    degraded: 50; // Medium reward for being in a degraded state
    failed: 0; // No reward for being in a failed state
endrewards

rewards "response_time"
    [detC] true: 0.000593486; // Time taken to detect controller failure (4 seconds)
    [fdetC] true: 0.00015; // Time taken for failing to detect controller failure
    [trigger_logs] true: 0.0000125; // Time taken to trigger logs
    [fail] true: 0.50; // Time taken to handle failure
endrewards

rewards "operational_efficiency"
    (sw=9) & (c=5): 1.00; // Highest efficiency when all switches and controllers are operational
    (sw<9) & (c=5): 0.75; // Reduced efficiency when switches are down but controllers are fully operational
    (sw=9) & (c<5): 0.50; // Reduced efficiency when controllers are down but switches are fully operational
    (sw<9) & (c<5): 0.25; // Lower efficiency when both switches and controllers are down
endrewards


rewards "maintenance_cost"
    [repair] true : 20; // Cost for performing repair actions
    [switch_fails] true : 10; // Cost when a switch fails
    [controller_fails] true : 15; // Cost when a controller fails
endrewards

